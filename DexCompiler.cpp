/*********************************************************************************/
/*                                                                               */
/*                                   DexCompiler.cpp                             */
/*                                                                               */
/*********************************************************************************/

#include <windows.h>
#include <mmsystem.h>

#include "..\DexSimulatorApp\resource.h"

#include <stdio.h>
#include <io.h>
#include <stdlib.h>
#include <math.h>
#include <time.h> 
#include <memory.h>
#include <process.h>

#include <OpenGLViewpoints.h>

#include <VectorsMixin.h> 
#include <fOutputDebugString.h>
#include <fMessageBox.h>

#include "Dexterous.h"
#include "DexMonitorServer.h"
#include "DexSounds.h"
#include "DexTargets.h"
#include "DexTracker.h"
#include "DexApparatus.h"

#include "DexInterpreterFunctions.h"

extern HINSTANCE app_instance;
extern HWND	workspace_dlg;
extern BOOL CALLBACK dexDlgCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern BOOL CALLBACK _dexPopupCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/***************************************************************************/
/*                                                                         */
/*                                DexCompiler                              */
/*                                                                         */
/***************************************************************************/

//
// Doesn't actually do anything. Instead, it just writes out each essential
// command to a script to be executed later by the interpreter.
//
	
DexCompiler::DexCompiler( char *filename ) {

	script_filename = filename;

}

void DexCompiler::Initialize( void ) {
	
	
	nVerticalTargets = N_VERTICAL_TARGETS;
	nHorizontalTargets = N_HORIZONTAL_TARGETS;
	nTargets = nVerticalTargets + nHorizontalTargets;

	// Create bit masks for the horizontal and vertical targets.
	// If you change something here, don't forget to change it in the base class DexApparatus as well.
	verticalTargetMask = 0;
	for ( int i = 0; i < nVerticalTargets; i++ ) verticalTargetMask = ( verticalTargetMask << 1 ) + 1;
	horizontalTargetMask = 0;
	for ( i = 0; i < nHorizontalTargets; i++ ) horizontalTargetMask = ( horizontalTargetMask << 1 ) + 1;
	horizontalTargetMask = horizontalTargetMask << nVerticalTargets;

	nTones = N_TONES;
	nCodas = N_CODAS;
	nMarkers = N_MARKERS;
	nChannels = N_CHANNELS;


	// Open a file into which we will write the script.
	fp = fopen( script_filename, "w" );
	if ( !fp ) {
		char message[1024];
		sprintf( message, "Error opening script file for write:\n  %s", script_filename );
	}

	// Write out comments as a header to the file.

	char date_str [9];
	char time_str [9];
	_strdate( date_str);
	_strtime( time_str );

	fprintf( fp, "#\n" );
	fprintf( fp, "# Filename: %s\n", script_filename );
	fprintf( fp, "# Created:  %s %s\n", date_str, time_str );
	fprintf( fp, "#\n" );
	fprintf( fp, "\n" );
	fprintf( fp, "# This script is automatically generated by the PsyPhy DEX simulator. \n" );
	fprintf( fp, "# You are strongly discouraged from editing this file directly. \n" );
	fprintf( fp, "\n" );

	// Keep track of step number.
	// Step numbers are output as comments just before each executable step in the script file.
	// This allows one to easily find offending commands when the DEX interpreter signals an error.

	nextStep = 1;

	// Show warnings or not.
	verbose = false;
	pause_on_warning = false;

	
	// The base class sets the targets and sounds off at initialization.
	// DEX does that automatically, so I removed those commands from the compiler.
	// Comment( "Start with all the targets and sounds off, but don't signal the event." );
	// SetTargetStateInternal( 0x00000000 );
	// SetSoundStateInternal( 0, 0 );

	
}

void DexCompiler::CloseScript( void ) {
	fclose( fp );
}

void DexCompiler::Quit( void ) {

	CloseScript();

}

/***************************************************************************/

// Translate the full-width target bit pattern used by the simulator into
// separate bit patterns for the horizontal and vertical targets used by
// the DEX hardware.

unsigned short DexCompiler::verticalTargetBits( unsigned long targetBits ) {
	return( targetBits & verticalTargetMask );
}
unsigned short DexCompiler::horizontalTargetBits( unsigned long targetBits ) {
	return( (targetBits & horizontalTargetMask) >> nVerticalTargets );
}

unsigned short DexCompiler::verticalTargetBit( int target_id ) {
	if ( target_id < nVerticalTargets ) return( 0x01 << target_id );
	else return( 0 );
}
unsigned short DexCompiler::horizontalTargetBit( int target_id) {
	if ( target_id >= nVerticalTargets ) return( 0x01 << ( target_id - nVerticalTargets ) );
	else return( 0 );
}

/***************************************************************************/

void DexCompiler::fWarning( const char *format, ... ) {
	
	va_list args;
	char message[10240];
	
	va_start(args, format);
	vsprintf(message, format, args);
	va_end(args);

	if ( pause_on_warning ) {
		int response = MessageBox( NULL, message, "DexCompiler", MB_OKCANCEL | MB_ICONQUESTION );
		if ( response != IDOK ) exit( -1 );
	}
	else {
		char message2[10240];
		strcpy( message2, "*** " );
		strcat( message2, message );
		strcat( message2, "\n" );
		fprintf( stderr, message2 );
	}

}



/***************************************************************************/

// Message strings have to be quoted by the DEX interpreter.
// This puts quotes into the string itself.
// Also, they have a limited length and for the moment commas have to be replaced.

// The return value is a pointer to a static string that gets overwritten every time
//  this routine is called. Since in general the result is used just once in a printf
//  statement, this should not be a problem. But if you want to save the result, 
//  you need to copy the resulting string.

char *DexCompiler::quoteMessage( const char *message ) {

	static char result[ 2 * DEX_MAX_MESSAGE_LENGTH ];

	if ( !message ) {
		return( "" );
	}

	int j = 0;

	// Limit the message to the size handled by DEX and replace some special characters.
	for ( int i = 0; i < DEX_MAX_MESSAGE_LENGTH && j < sizeof( result ) - 1 && message[i] != 0; i++ ) {
		// Transform linebreaks into \n.
		if ( message[i] == '\n' ) {
			if ( i == DEX_MAX_MESSAGE_LENGTH - 1) break;
			result[j++] = '\\';
			result[j++] = 'n';
		}
		// The DEX parser requires that commas be escaped.
		else if ( message[i] == ',' ) {
			result[j++] = '\\';
			result[j++] = ',';
		}
		// Otherwise, just copy.
		else result[j++] = message[i];

	}
	result[j++] = 0;

	if ( strlen( result ) > DEX_MAX_MESSAGE_LENGTH ) {
		char original[10240];
		strcpy( original, result );
		result[DEX_MAX_MESSAGE_LENGTH - 1] = 0;
		fWarning( "WARNING: Message too long. Truncating.\n%s\n%s\n" , original, result );
	}

	if ( strlen( result ) == 0 ) strcpy( result, " " );

	return( result );

}

/***************************************************************************/

int DexCompiler::SelfTest( void ) {
	AddStepNumber();
	fprintf( fp, "CMD_SELFTEST\n" );
	return( NORMAL_EXIT );
}


/***************************************************************************/

int DexCompiler::WaitSubjectReady( const char *picture, const char *message ) {

	// I did not foresee a timeout for this command. I am setting the timeout 
	// to the maximum. Maybe this needs to be changed.
	AddStepNumber();
	fprintf( fp, "CMD_WAIT_SUBJ_READY,%s,%s,%.0f\n", quoteMessage( message ), picture, DEX_MAX_TIMEOUT );
	return( NORMAL_EXIT );
}

/***************************************************************************/

void DexCompiler::Wait( double duration ) {
	AddStepNumber();
	fprintf( fp, "CMD_WAIT, %.0f\n", duration * 1000.0 );
}

/***************************************************************************/

int DexCompiler::WaitUntilAtTarget( int target_id, 
									const Quaternion desired_orientation,
									Vector3 position_tolerance, 
									double orientation_tolerance,
									double hold_time, 
									double timeout, 
									const char *msg, const char *picture  ) {

	AddStepNumber();
	fprintf( fp, "CMD_WAIT_MANIP_ATTARGET, 0x%04x, 0x%04x, %f, %f, %f, %f, %.0f, %.0f, %.0f, %.0f, %.0f, %.0f,%s,%s\n",
		horizontalTargetBit( target_id ), verticalTargetBit( target_id ), 
		desired_orientation[X], desired_orientation[Y], desired_orientation[Z], desired_orientation[M], 
		position_tolerance[X], position_tolerance[Y], position_tolerance[Z], orientation_tolerance,
		hold_time * 1000, timeout, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

/***************************************************************************/

int	 DexCompiler::WaitCenteredGrip( float tolerance, float min_force, float timeout, const char *msg, const char *picture ) {
	static bool once = false;
	if ( timeout > DEX_MAX_TIMEOUT && !once ) {
		once = true;
		if ( verbose ) fWarning( "Warning - Timeout exceeds limit." );
	}
	if ( timeout < 0 && !once ) {
		once = true;
		if ( verbose ) fWarning( "Warning - Timeout cannot be negative." );
	}
	AddStepNumber();
	fprintf( fp, "CMD_WAIT_MANIP_GRIP, %f, %.0f, %f,%s, \n", min_force, tolerance, timeout, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int	DexCompiler::WaitDesiredForces( float min_grip, float max_grip, 
								 float min_load, float max_load,
								 Vector3 direction, float filter_constant,
								 float hold_time, float timeout, const char *msg, const char *picture ) {

	AddStepNumber();
	fprintf( fp, "CMD_WAIT_MANIP_GRIPFORCE, %f, %f, %f, %f, %f, %f, %f, %.0f, %.0f, %f,%s,%s\n",
		min_grip, max_grip, min_load, max_load, direction[X], direction[Y], direction[Z], 
		hold_time * 1000.0, timeout, filter_constant, quoteMessage( msg ), ( picture ? picture : "" ) );

	return( NORMAL_EXIT );
}



int DexCompiler::WaitSlip( float min_grip, float max_grip, 
								 float min_load, float max_load, 
								 Vector3 direction,
								 float filter_constant,
								 float slip_threshold, 
								 float timeout, const char *msg, const char *picture ) {

	AddStepNumber();
	fprintf( fp, "CMD_WAIT_MANIP_SLIP, %f, %f, %f, %f, %f, %f, %f, %.0f, %.0f, %f,%s,%s\n",
		min_grip, max_grip, min_load, max_load, direction[X], direction[Y], direction[Z], 
		slip_threshold, timeout, filter_constant, quoteMessage( msg ), ( picture ? picture : "" ) );

	return( NORMAL_EXIT );
}

/***************************************************************************/

int DexCompiler::SelectAndCheckConfiguration( const char *picture, const char *message, int posture, int bar_position, int tapping ) {

	double timeout;

	// I am putting the maximum for the timeout, because I don't believe that this one should timeout.
	timeout = DEX_MAX_TIMEOUT;

	// I had three states for posture and bar position, including an 'indifferent' state. 
	// Here I translate those to the 0 and 1 defined by DEX.
	// Note that DEX has no way to check whether the tapping surfaces are deployed or not, so 
	//  the tapping parameter is ignored.
	AddStepNumber();
	fprintf( fp, "CMD_CHK_HW_CONFIG,%s,%s, %d, %d, %.0f \n", quoteMessage( message ), picture, 
		( posture == PostureSeated ? 0 : 1 ), ( bar_position == TargetBarLeft ? 1 : 0 ), timeout );
	return( NORMAL_EXIT );
}

#if 0
int DexCompiler::SelectAndCheckConfiguration( int posture, int bar_position, int tapping ) {

	char message[256];
	char *picture;
	double timeout;

	sprintf( message, "Please set the following configuration:\\n   Posture: %s   Target Bar: %s",
		( posture ? "supine" : "seated" ),
		( bar_position ? "Right" : "Left" ));
	AddStepNumber();

	// Select a picture file depending on the desired configuration.
	// This picture will be displayed if the configuration needs to be corrected.
	if ( posture == PostureSupine ) {
		if ( bar_position == TargetBarLeft ) picture = "SupineAside.bmp";
		else picture = "SupineInUse.bmp";
	}
	else {
		if ( bar_position == TargetBarLeft ) picture = "SitAside.bmp";
		else picture = "SitInUse.bmp";
	}

	// I am putting the maximum for the timeout, because I don't believe that this one should timeout.
	timeout = DEX_MAX_TIMEOUT;

	// I had three states for posture and bar position, including an 'indifferent' state. 
	// Here I translate those to the 0 and 1 defined by DEX.
	// Note that DEX has no way to check whether the tapping surfaces are deployed or not, so 
	//  the tapping parameter is ignored.
	fprintf( fp, "CMD_CHK_HW_CONFIG,%s,%s, %d, %d, %.0f \n", quoteMessage( message ), picture, 
		( posture == PostureSeated ? 0 : 1 ), ( bar_position == TargetBarLeft ? 1 : 0 ), timeout );
	return( NORMAL_EXIT );
}
#endif
/*********************************************************************************/

int DexCompiler::SelectAndCheckMass( int mass ) {

	int mass_id;

	if ( mass == MassIndifferent ) return( NORMAL_EXIT );
	if ( mass == MassNone ) MessageBox( NULL, "DEX does not handle MassNone.", "DexApparatus", MB_OK );
	else if ( mass == MassSmall ) mass_id = 0;
	else if ( mass == MassLarge ) mass_id = 2;
	else mass_id = 1;

	AddStepNumber();
	fprintf( fp, "CMD_CHK_MASS_SELECTION, Select mass,TakeMass.bmp, %d, %.0f\n", mass_id, DEX_MAX_TIMEOUT );
	return( NORMAL_EXIT );
}



/**************************************************************************************************************/

// These commands are used to set the target and sound states.
// Here I have replaced the lowest level command which does that and only that.
// The higher level commands SetTargetStateInternal() and SetSoundState() call
//  these routines, and they automatically make calls to log the events.
// If CMD_CTRL_TARGETS and CMD_CTRL_TONE also automatically log events, then
//  one should change these funtions to overlay SetTargetStateInternal() and SetSoundState() instead.

void DexCompiler::SetTargetStateInternal( unsigned long target_state ) {

	// I assumed that targets will be set with a single 32-bit word.
	// Instead, DEX treats horizontal and vertical with separate 16-bit words.
	// Here I reconstuct the two DEX bits patterns from the simulator bit pattern.
	unsigned short vstate, hstate;
	vstate = verticalTargetBits( target_state );
	hstate = horizontalTargetBits( target_state );
	AddStepNumber();
	fprintf( fp, "CMD_CTRL_TARGETS, 0x%04x, 0x%04x\n", hstate, vstate );
}

void DexCompiler::SetSoundStateInternal( int tone, int volume ) {
	static bool once = false;
	if ( volume != 0 && volume != 1 && !once ) {
		if ( verbose ) fWarning( "Warning - Sound volume on DEX is 0 or 1" );
		once = true;
	}
	if ( ( tone < 0 || tone >= nTones ) && !once ) {
		fWarning( "Warning - Tone is out of range." );
		once = true;
	}
	AddStepNumber();
	// On DEX, the bit is actually 'mute' or 'not mute'. This volume (on or off) to mute (on or off).
	fprintf( fp, "CMD_CTRL_TONE, %d, %d\n", ( volume ? 0 : 1 ), tone );
}

/**************************************************************************************************************/

int DexCompiler::CheckVisibility( double max_cumulative_dropout_time, double max_continuous_dropout_time, const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_MANIP_VISIBILITY, %f, %f,%s,%s\n", 
		max_cumulative_dropout_time, max_continuous_dropout_time, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int DexCompiler::CheckMovementAmplitude(  double min, double max, 
										   double dirX, double dirY, double dirZ,
										   const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_MOVEMENTS_AMPL, %.0f, %.0f, %f, %f, %f,%s,%s \n", 
		min, max, dirX, dirY, dirZ, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int DexCompiler::CheckMovementCycles(  int min_cycles, int max_cycles, 
							float dirX, float dirY, float dirZ,
							float hysteresis, const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_MOVEMENTS_CYCLES, %d, %d, %f, %f, %f, %.0f,%s,%s \n", 
		min_cycles, max_cycles, dirX, dirY, dirZ, hysteresis, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int DexCompiler::CheckEarlyStarts(  int n_false_starts, float hold_time, float threshold, float filter_constant, const char *msg, const char *picture ) {
	if (verbose ) fWarning( "CheckEarlyStarts()\nWhat about the filter constant?!?!" );
	if ( threshold >= 2.0 ) {
		fWarning( "CheckEarlyStarts()\nVelocity threshold %f exceeds limit.", threshold );
		threshold = 1.999;
	}
	AddStepNumber();
	fprintf( fp, "CMD_CHK_EARLYSTARTS, %d, %.0f, %.0f, %f,%s,%s\n", n_false_starts, hold_time * 1000, threshold * 1000, filter_constant, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}
int DexCompiler::CheckCorrectStartPosition( int target_id, float tolX, float tolY, float tolZ, int max_n_bad, const char *msg, const char *picture ) {

	unsigned short horizontal = horizontalTargetBit( target_id );
	unsigned short vertical = verticalTargetBit( target_id );

	AddStepNumber();
	fprintf( fp, "CMD_CHK_START_POS, 0x%04x, 0x%04x, %.0f, %.0f, %.0f, %d,%s,%s\n", 
		horizontal, vertical, tolX, tolY, tolZ, max_n_bad, quoteMessage( msg ), ( picture ? picture : "" ) );
	
	return( NORMAL_EXIT );
}
int DexCompiler::CheckMovementDirection(  int n_false_directions, float dirX, float dirY, float dirZ, float threshold, const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_MOVEMENTS_DIR, %d, %f, %f, %f, %.1f,%s,%s \n", 
		n_false_directions, dirX, dirY, dirZ, threshold, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}
int DexCompiler::CheckForcePeaks( float min_force, float max_force, int max_bad_peaks, const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_COLLISIONFORCE, %f, %f, %d,%s,%s \n", 
		min_force, max_force, max_bad_peaks, quoteMessage( msg ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
};

void DexCompiler::ComputeAndNullifyStrainGaugeOffsets( void ) {
	AddStepNumber();
	fprintf( fp, "CMD_NULLIFY_FORCES, ERROR????\n" );
};


/**************************************************************************************************************/

void DexCompiler::StartAcquisition( const char *tag, float max_duration ) {
	// DEX ignores the max duration parameter.
	char truncated[256];
	strcpy( truncated, tag );
	if ( strlen( truncated ) > 8 ) {
		truncated[8] = 0;
		fWarning( "WARNING: File tag too long. Truncating.\n%s\n%s\n", tag, truncated );
	}

	AddStepNumber();
	fprintf( fp, "CMD_ACQ_START,%s\n", truncated );  // Need to confirm if the tag should be quoted or not.
	// Note the time of the acqisition start.
	MarkEvent( ACQUISITION_START );
}

int DexCompiler::StopAcquisition( const char *msg ) {
	MarkEvent( ACQUISITION_STOP );
	AddStepNumber();
	fprintf( fp, "CMD_ACQ_STOP,%s\n", quoteMessage( msg ) );
	return( NORMAL_EXIT );
}

/*********************************************************************************/

int DexCompiler::PerformTrackerAlignment( const char *message, const char *picture ) {


	AddStepNumber();
	fprintf( fp, "CMD_ALIGN_CODA,%s,%s \n", quoteMessage( message ), ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int DexCompiler::CheckTrackerAlignment( unsigned long marker_mask, float tolerance, int n_good, const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_CODA_ALIGNMENT, 0x%08lx, %.0f, %d,%s,%s \n", 
		marker_mask, tolerance, n_good, quoteMessage( msg ),  ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int DexCompiler::CheckTrackerFieldOfView( int unit, unsigned long marker_mask, 
										   float min_x, float max_x,
										   float min_y, float max_y,
										   float min_z, float max_z, const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_CODA_FIELDOFVIEW, %d, 0x%08lx, %.0f, %.0f, %.0f, %.0f, %.0f, %.0f,%s,%s\n", 
		unit + 1, marker_mask, min_x, max_x, min_y, max_y, min_z, max_z, quoteMessage( msg ),  ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

int DexCompiler::CheckTrackerPlacement( int unit, 
										const Vector3 expected_pos, float p_tolerance,
										const Quaternion expected_ori, float o_tolerance,
										const char *msg, const char *picture ) {
	AddStepNumber();
	fprintf( fp, "CMD_CHK_CODA_PLACEMENT, %d, %.0f, %.0f, %.0f, %f, %f, %f, %f, %.0f, %.0f,%s,%s \n", 
		unit + 1, expected_pos[X], expected_pos[Y], expected_pos[Z],  
		expected_ori[X], expected_ori[Y], expected_ori[Z], expected_ori[M], 
		p_tolerance, o_tolerance, quoteMessage( msg ),  ( picture ? picture : "" ) );
	return( NORMAL_EXIT );
}

/*********************************************************************************/


void DexCompiler::MarkEvent( int event, unsigned long param ) {
	AddStepNumber();
	fprintf( fp, "CMD_LOG_EVENT, %d\n", event );
}

void DexCompiler::SignalEvent( const char *event ) {
	AddStepNumber();
	// Log a message, without showing it to the subject.
	fprintf( fp, "CMD_LOG_MESSAGE, 0,%s\n", quoteMessage( event ) );
}

void DexCompiler::ShowStatus (const char *message, const char *picture ) {
	AddStepNumber();
	// Log the message and show it on the DEX screen.
	fprintf( fp, "CMD_LOG_MESSAGE, 1,%s\n", quoteMessage( message ) );
	AddStepNumber();
	fprintf( fp, "CMD_SET_PICTURE,%s\n", ( picture ? picture : "") );
}

void DexCompiler::Comment( const char *txt ) {
	fprintf( fp, "\n#%s\n", txt );
}

void DexCompiler::AddStepNumber( void ) {
	fprintf( fp, "# Step %08d\n", nextStep++ );
}

/*********************************************************************************/

// The following routines do not output anything to the scripts. 
// They represent stuff that cannot be executed by DEX.
// Here we flag them during compilation, in case the user tries to
// include them in a script.

void DexCompiler::UnhandledCommand( const char *cmd ) {
	char msg[2048];
	sprintf( msg, "Warning - Command is not handled by DEX script processor: %s", cmd );
	MessageBox( NULL, msg, "DEX Compiler Warning", MB_OK | MB_ICONHAND );
}
void DexCompiler::SetTargetPositions( void ) { 
	static bool first = true;
	if ( first ) UnhandledCommand( "SetTargetPositions()" );
	first = false;
}
void DexCompiler::SignalConfiguration( void ) {
	static bool first = true;
	if ( first ) UnhandledCommand( "SignalConfiguration()" );
	first = false;
}

int DexCompiler::CheckAccelerationPeaks( float min_amplitude, float max_amplitude, int max_bad_peaks, const char *msg, const char *picture ){ 
	static bool first = true;
	if ( first ) UnhandledCommand( "CheckAccelerationPeaks()" );
	first = false;
	return( NORMAL_EXIT ); 
}

void DexCompiler::StartFilming( const char *tag, int fps ) {
	strncpy( hold_film_tag, tag, 8 );
	hold_film_tag[8] = 0;
	AddStepNumber();
	fprintf( fp, "CMD_CFG_CAMERA, %d\n", fps );
	AddStepNumber();
	fprintf( fp, "CMD_CTRL_CAMERA, 1, %8s\n", hold_film_tag );
}
void DexCompiler::StopFilming( void ) {
	AddStepNumber();
	fprintf( fp, "CMD_CTRL_CAMERA, 0, %8s\n", hold_film_tag );
}

/*********************************************************************************/

/* 
 * The DexCompiler apparatus generates a script of the top-level commands.
 * Here we run the set of steps defined by such a script, instead of running 
 * a protocol defined by a C subroutine (as above).
 */

// Post Hoc tests not yet implemented.

int RunScript( DexApparatus *apparatus, const char *filename ) {
	
	FILE *fp;
	int status = 0;
	char line[1024];
	int	 line_n = 0;

	int tokens;
	char *token[MAX_TOKENS];
	char hold_status_message[1024]="";

	int i;

	fp = fopen( filename, "r" );
	if ( !fp ) {
		char message[1024];
		sprintf( message, "Error opening script file:\n  %s", filename );
		MessageBox( NULL, message, "DEX Error", MB_OK );
		return( ERROR_EXIT );
	}
	
	while ( fgets( line, sizeof( line ), fp ) ) {
		
		// Count the lines.
		line_n++;

		// Break the line into pieces as defined by the DEX/GRIP ICD.
		tokens = ParseCommaDelimitedLine( token, line );
		fOutputDebugString( "\n\n" );
		fOutputDebugString( "Line:   %s", line );
		fOutputDebugString( "Tokens: %d\n", tokens );
		for ( i = 0; i < tokens; i++ ) {
			fOutputDebugString( "%2d %03d %s %s\n", i, strlen( token[i] ), ( strlen( token[i] ) > DEX_MAX_MESSAGE_LENGTH ? "!!!" : "   " ), token[i] );
			if ( strlen( token[i] ) > DEX_MAX_MESSAGE_LENGTH ) {
				char message[1024];
				sprintf( message, "Token exceeds max length:  %d  %s", strlen( token[i] ), token[i] );
				MessageBox( NULL, message, "DEX Error", MB_OK );
			}
		}

		if ( tokens < 1 ) {}
		else if ( !strcmp( token[0], "CMD_WAIT_SUBJ_READY" ) ) {
			status = apparatus->WaitSubjectReady( token[2], token[1] );
		}
		else if ( !strcmp( token[0], "CMD_WAIT" ) ) {
			double duration = atof( token[1] ) / 1000.0;
			apparatus->Wait( duration );
		}
		else if ( !strcmp( token[0], "CMD_CTRL_TONE" ) ) {
			// CMD_CTRL_TONE on DEX takes a mute flag (0 or 1) and a tone selection (1=7).
			// Here we convert that to the simulator's API where the parameters
			//  are tone and volume.
			int mute = atoi( token[1] );
			int tone = atoi( token[2] );
			apparatus->SetSoundStateInternal( tone, ( mute ? 0 : N_VOLUMES - 1 ));
		}
		else if ( !strcmp( token[0], "CMD_CTRL_TARGETS" ) ) {
			unsigned int h;
			unsigned int v;
			unsigned long bits;
			sscanf( token[1], "%x", &h );
			sscanf( token[2], "%x", &v );
			bits = (h << apparatus->nVerticalTargets) | v;
			apparatus->SetTargetStateInternal( bits );
		}
		else if ( !strcmp( token[0], "CMD_WAIT_MANIP_ATTARGET" ) ) {

			int target_id;
			Vector3 position_tolerance;
			Quaternion desired_orientation;
			double orientation_tolerance;
			double hold_time;
			double timeout;

			unsigned long h, v;
			
			sscanf( token[2], "%lx", &v );
			sscanf( token[1], "%lx", &h );

			unsigned long target_bits  = (h << apparatus->nVerticalTargets) | v;
			for ( target_id = 0; target_id < apparatus->nTargets; target_id++ ) {
				if ( target_bits & 0x01 ) break;
				target_bits = target_bits >> 1;
			}

			desired_orientation[X] = atof( token[3] );
			desired_orientation[Y] = atof( token[4] );
			desired_orientation[Z] = atof( token[5] );
			desired_orientation[M] = atof( token[6] );

			position_tolerance[X] = atof( token[7] );
			position_tolerance[Y] = atof( token[8] );
			position_tolerance[Z] = atof( token[9] );

			orientation_tolerance = atof( token[10] );

			hold_time = atof( token[11] ) / 1000.0;
			timeout = atof( token[12] );

			do {
				status = apparatus->WaitUntilAtTarget( target_id, desired_orientation, position_tolerance, orientation_tolerance, hold_time, timeout, token[13], token[14] );
			} while ( status == RETRY_EXIT );

		}
		else if ( !strcmp( token[0], "CMD_WAIT_MANIP_GRIP" ) ) {
			status = apparatus->WaitCenteredGrip( 
				atof( token[2] ), // min_force
				atof( token[1] ), // tolerance
				atof( token[3] ), // timeout
				token[4], // message
				token[5] ); // picture
		}
		else if ( !strcmp( token[0], "CMD_WAIT_MANIP_GRIPFORCE" ) ) {

			Vector3 direction;

			direction[X] = atof( token[5] );
			direction[Y] = atof( token[6] );
			direction[Z] = atof( token[7] );

			status = apparatus->WaitDesiredForces( 
				atof( token[1] ), // min_grip
				atof( token[2] ), // max_grip
				atof( token[3] ), // min_load
				atof( token[4] ), // max_load
				direction,
				atof( token[10] ), // filter_constant
				atof( token[8] ) / 1000.0, // hold_time
				atof( token[9] ), // timeout
				token[11], // message
				token[12]  // picture
			); 
		}

		else if ( !strcmp( token[0], "CMD_WAIT_MANIP_SLIP" ) ) {

			Vector3 direction;

			direction[X] = atof( token[5] );
			direction[Y] = atof( token[6] );
			direction[Z] = atof( token[7] );

			do {
				status = apparatus->WaitSlip( 
					atof( token[1] ), // min_grip
					atof( token[2] ), // max_grip
					atof( token[3] ), // min_load
					atof( token[4] ), // max_load
					direction,
					atof( token[10] ), // filter_constant
					atof( token[8] ), // slip_threshold
					atof( token[9] ), // timeout
					token[11], // message
					token[12]  // picture
				); 
			} while ( status == RETRY_EXIT );
		}
		else if ( !strcmp( token[0], "CMD_CHK_HW_CONFIG" ) ) {
			status = apparatus->SelectAndCheckConfiguration( 
				token[2], // picture
				token[1], // message
				( atoi( token[3] ) ? PostureSupine : PostureSeated ), // posture
				( atoi( token[4] ) ? TargetBarLeft : TargetBarRight ), // bar_position
				TappingIndifferent
			);
		}
		else if ( !strcmp( token[0], "CMD_CHK_MASS_SELECTION" ) ) {
			DexMass mass_id[] = { MassSmall, MassMedium, MassLarge };
			do {
				status = apparatus->SelectAndCheckMass( mass_id[ atoi( token[3] ) ] );
			} while ( status == RETRY_EXIT );
		}
		else if ( !strcmp( token[0], "CMD_NULLIFY_FORCES" ) ) {
			apparatus->ComputeAndNullifyStrainGaugeOffsets();
		}
		else if ( !strcmp( token[0], "CMD_ACQ_START" ) ) {
			apparatus->StartAcquisition( token[1], 300.0 );
		}
		else if ( !strcmp( token[0], "CMD_ACQ_STOP" ) ) {
			status = apparatus->StopAcquisition( token[1] );
		}
		else if ( !strcmp( token[0], "CMD_ALIGN_CODA" ) ) {
			status = apparatus->PerformTrackerAlignment( 
				token[1], // message
				token[2] // picture
			);
		}
		else if ( !strcmp( token[0], "CMD_CHK_CODA_ALIGNMENT" ) ) {
			unsigned long marker_mask;
			sscanf( token[1], "%lx", &marker_mask );
			status = apparatus->CheckTrackerAlignment( 
				marker_mask,
				atof( token[2] ), // tolerance
				atoi( token[3] ), // n_good
				token[4], // message
				token[5] // picture
			);
		}
		else if ( !strcmp( token[0], "CMD_CHK_CODA_FIELDOFVIEW" ) ) {
			unsigned long marker_mask;
			sscanf( token[2], "%lx", &marker_mask );
			status = apparatus->CheckTrackerFieldOfView( 
				atoi( token[1] ) - 1,
				marker_mask,
				atof( token[3] ), // min_x
				atof( token[4] ), // max_x
				atof( token[5] ), // min_y
				atof( token[6] ), // max_y
				atof( token[7] ), // min_z
				atof( token[8] ), // max_z
				token[9], // message
				token[10] // picture
			);
		}
		else if ( !strcmp( token[0], "CMD_CHK_CODA_PLACEMENT" ) ) {
			int unit = atoi( token[1] ) - 1;
			Vector3 expected_pos;
			float p_tolerance = atof( token[9] );
			Quaternion expected_ori;
			float o_tolerance = atof( token[10] );

			expected_pos[X] = atof( token[2] );
			expected_pos[Y] = atof( token[3] );
			expected_pos[Z] = atof( token[4] );

			expected_ori[X] = atof( token[5] );
			expected_ori[Y] = atof( token[6] );
			expected_ori[Z] = atof( token[7] );
			expected_ori[M] = atof( token[8] );

			status = apparatus->CheckTrackerPlacement( 
				unit,
				expected_pos,
				p_tolerance,
				expected_ori,
				o_tolerance,
				token[11], // message
				token[12] // picture
			);
		}
		else if ( !strcmp( token[0], "CMD_LOG_EVENT" ) ) {
			apparatus->MarkEvent( atoi( token[1] ) );
		}
		else if ( !strcmp( token[0], "CMD_LOG_MESSAGE" ) ) {
			int value, items;
			if ( !strcmp( token[1], "logmsg" ) ) value = 0;
			else if ( !strcmp( token[1], "usermsg" ) ) value = 1;
			else {
				items = sscanf( token[1], "%d", &value );
				value = items && value;
			}
			if ( value == 0 ) apparatus->SignalEvent( token[2] );
			else {
				if ( token[2] ) strcpy( hold_status_message, token[2] );
				else strcpy( hold_status_message, "" );
				apparatus->ShowStatus( hold_status_message, "blank.bmp" );
			}
		}
		else if ( !strcmp( token[0], "CMD_SET_PICTURE" ) ) {
			apparatus->ShowStatus( hold_status_message,token[1] );
		}
		else if ( !strcmp( token[0], "CMD_SELFTEST" ) ) {
		}
		else if ( !strcmp( token[0], "CMD_CFG_CAMERA" ) ) {
		}
		else if ( !strcmp( token[0], "CMD_CTRL_CAMERA" ) ) {
			int value, items;
			items = sscanf( token[1], "%d", &value );
			value = items && value;
			if ( value ) apparatus->StartFilming( token[2], 2 );
			else apparatus->StopFilming();
		}
		else {
//			fMessageBox( MB_OK, "DEX Interpreter", "Unrecognize command:\n%s", line );
		}

		if ( status == RETRY_EXIT || status == ABORT_EXIT ) break;

	}
	fclose( fp );
	
	// If we exit the script with a retry, run the script again recursively.
	if ( status == RETRY_EXIT ) status = RunScript( apparatus, filename );

	return( status );
	
}

/*********************************************************************************************************************************/

#define MAX_MENU_ITEMS			256
#define	MAX_MENU_LABEL_LENGTH	64
#define	MAX_MENU_DATA_LENGTH	1024

char _dex_task_menu_list[MAX_MENU_ITEMS][MAX_MENU_LABEL_LENGTH];
char _dex_task_menu_data[MAX_MENU_ITEMS][MAX_MENU_DATA_LENGTH];
int  _dex_task_menu_list_items;
int  _dex_task_menu_selected_item;

// This callback is used for 'popups'. When they close, the APP keeps on going.
BOOL CALLBACK _dexTaskListCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

	int i;
	HFONT hFont;

	switch (message)
	{
	case WM_INITDIALOG:

		SetDlgItemText( hDlg, IDC_MESSAGE, "Select task and press OK." );
		hFont = CreateFont (36, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, "Arial");
		SendDlgItemMessage( hDlg, IDC_LIST, WM_SETFONT, WPARAM (hFont), TRUE);
		for ( i = 0; i < _dex_task_menu_list_items; i++ ) {
			SendDlgItemMessage( hDlg, IDC_LIST, LB_INSERTSTRING, i, (LPARAM) TEXT(_dex_task_menu_list[i]) );
			SendDlgItemMessage( hDlg, IDC_LIST, LB_SETITEMDATA, i, (LPARAM) TEXT(_dex_task_menu_data[i]) );		
			SendDlgItemMessage( hDlg, IDC_LIST, LB_SETCURSEL, _dex_task_menu_selected_item, (LPARAM) 0  );		
		}

   		return TRUE;
		break;
		
	case WM_PAINT:
		// The following is a hack. DialogBox() disables the parent, but I want 
		//  the other controls to stay active. So I re-enable the parent.
		// Why is it in WM_PAINT? Because WM_INITDIALOG is too early.
		EnableWindow( GetParent( hDlg ), true );
   		return TRUE;
		break;

    case WM_CLOSE:
		EndDialog(hDlg, NULL );
		return TRUE;
		break;
		
 
	case WM_COMMAND:

		switch ( LOWORD( wParam ) ) {
		case IDCANCEL:
			EndDialog(hDlg, NULL);
			return TRUE;
			break;
		case IDOK:
			_dex_task_menu_selected_item = (int) SendDlgItemMessage(hDlg, IDC_LIST, LB_GETCURSEL, 0, 0); 
			EndDialog(hDlg, SendDlgItemMessage( hDlg, IDC_LIST, LB_GETITEMDATA, _dex_task_menu_selected_item, 0 ));
			return TRUE;
			break;
		}
	}
    return FALSE;
}

void fill_task_menu( char labels[MAX_MENU_ITEMS][MAX_MENU_LABEL_LENGTH], char paths[MAX_MENU_ITEMS][MAX_MENU_DATA_LENGTH], int items ) {

	int i;
	for ( i = 0; i < items && i < MAX_MENU_ITEMS; i++ ) {
		strcpy( _dex_task_menu_list[i], labels[i] );
		strcpy( _dex_task_menu_data[i], paths[i] );
	}
	_dex_task_menu_list_items = items;
	_dex_task_menu_selected_item = 0;
}

char *select_task_from_menu( void ) {

	char *value = (char *) DialogBox( app_instance, (LPCSTR) IDD_SELECT, workspace_dlg, _dexTaskListCallback );
	if ( value ) _dex_task_menu_selected_item = (_dex_task_menu_selected_item + 1) % _dex_task_menu_list_items;
	return( value );

}

/*********************************************************************************************************************************/

int RunProtocol ( DexApparatus *apparatus, char *filename ) {

	FILE *fp;

	int tokens;
	char *token[MAX_TOKENS];
	char line[2048];
	int line_n = 0;
	int	i;

	char TaskFilePath[MAX_MENU_ITEMS][MAX_MENU_DATA_LENGTH];
	char TaskLabel[MAX_MENU_ITEMS][MAX_MENU_LABEL_LENGTH];
	int  tasks = 0;

	int errors = 0;

	char task_file[MAX_MENU_DATA_LENGTH], *tsk;

	fp = fopen( filename, "r" );
	if ( !fp ) {
		// Signal the error.
		fMessageBox( MB_OK, "RunProtocol", "    Error opening protocol file %s for read.\n", filename );
		// Tell the caller that we had just the one error.
		exit( -1 );
	}

	fOutputDebugString( "\n  File: %s", filename );

	tasks = 0;

	// Fill the menu line-by-line.
	while ( fgets( line, sizeof( line ), fp ) ) {

		line_n++;
		tokens = ParseCommaDelimitedLine( token, line );
		fOutputDebugString( "\n  Line:   %s", line );
		fOutputDebugString( "Tokens: %d\n", tokens );
		for ( i = 0; i < tokens; i++ ) fOutputDebugString( "%2d %s\n", i, token[i] );

		if ( tokens >= 4 ) {
			// This parameter is the name of the task file.
			strcpy( task_file, token[2] );
			// Check if it exists and is readable.
			if ( _access( task_file, 0x00 ) ) {
				fMessageBox( MB_OK, "Error", "  %s Line %03d Cannot access task file: %s\n", filename, line_n, task_file );
			}	
			else {
				strcpy( TaskFilePath[tasks], token[2] );
				strcpy( TaskLabel[tasks], token[3] );
				tasks++;
			}
		}
	}

	fill_task_menu( TaskLabel, TaskFilePath, tasks );
	while ( tsk = select_task_from_menu() ) {
		fOutputDebugString( "Selected task path: %s\n", tsk );
		RunScript( apparatus, tsk );
	}
	fclose( fp );
	return( errors );

}

/*********************************************************************************************************************************/

char _dex_protocol_menu_list[MAX_MENU_ITEMS][MAX_MENU_LABEL_LENGTH];
char _dex_protocol_menu_data[MAX_MENU_ITEMS][MAX_MENU_DATA_LENGTH];
char _dex_protocol_menu_prompt[MAX_MENU_DATA_LENGTH];
int  _dex_protocol_menu_list_items;
int  _dex_protocol_menu_selected_item;

// This callback is used for 'popups'. When they close, the APP keeps on going.
BOOL CALLBACK _dexProtocolListCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

	int i;
	HFONT hFont;

	switch (message)
	{
	case WM_INITDIALOG:

		SetDlgItemText( hDlg, IDC_MESSAGE, _dex_protocol_menu_prompt );
		hFont = CreateFont (36, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, "Arial");
		SendDlgItemMessage( hDlg, IDC_LIST, WM_SETFONT, WPARAM (hFont), TRUE);
		for ( i = 0; i < _dex_protocol_menu_list_items; i++ ) {
			SendDlgItemMessage( hDlg, IDC_LIST, LB_INSERTSTRING, i, (LPARAM) TEXT(_dex_protocol_menu_list[i]) );
			SendDlgItemMessage( hDlg, IDC_LIST, LB_SETITEMDATA, i, (LPARAM) TEXT(_dex_protocol_menu_data[i]) );		
			SendDlgItemMessage( hDlg, IDC_LIST, LB_SETCURSEL, _dex_protocol_menu_selected_item, (LPARAM) 0  );		
		}

   		return TRUE;
		break;
		
	case WM_PAINT:
		// The following is a hack. DialogBox() disables the parent, but I want 
		//  the other controls to stay active. So I re-enable the parent.
		// Why is it in WM_PAINT? Because WM_INITDIALOG is too early.
		EnableWindow( GetParent( hDlg ), true );
   		return TRUE;
		break;

    case WM_CLOSE:
		EndDialog(hDlg, NULL );
		return TRUE;
		break;
		
 
	case WM_COMMAND:

		switch ( LOWORD( wParam ) ) {
		case IDCANCEL:
			EndDialog(hDlg, NULL);
			return TRUE;
			break;
		case IDOK:
			_dex_protocol_menu_selected_item = (int) SendDlgItemMessage(hDlg, IDC_LIST, LB_GETCURSEL, 0, 0); 
			EndDialog(hDlg, SendDlgItemMessage( hDlg, IDC_LIST, LB_GETITEMDATA, _dex_protocol_menu_selected_item, 0 ));
			return TRUE;
			break;
		}
	}
    return FALSE;
}

void fill_protocol_menu( char labels[MAX_MENU_ITEMS][MAX_MENU_LABEL_LENGTH], char paths[MAX_MENU_ITEMS][MAX_MENU_DATA_LENGTH], const char *prompt, int items ) {

	int i;
	for ( i = 0; i < items && i < MAX_MENU_ITEMS; i++ ) {
		strcpy( _dex_protocol_menu_list[i], labels[i] );
		strcpy( _dex_protocol_menu_data[i], paths[i] );
	}
	_dex_protocol_menu_list_items = items;
	_dex_protocol_menu_selected_item = 0;
	strcpy( _dex_protocol_menu_prompt, prompt );
}

char *select_protocol_from_menu( void ) {

	char *value = (char *) DialogBox( app_instance, (LPCSTR) IDD_SELECT, workspace_dlg, _dexProtocolListCallback );
	if ( value ) _dex_protocol_menu_selected_item = (_dex_protocol_menu_selected_item + 1) % _dex_protocol_menu_list_items;
	return( value );

}

/*********************************************************************************************************************************/

int RunSession ( DexApparatus *apparatus, char *filename ) {

	FILE *fp;

	int tokens;
	char *token[MAX_TOKENS];
	char line[2048];
	int line_n = 0;
	int	i;

	char ProtocolFilePath[32][1024];
	char ProtocolLabel[32][64];
	int  protocols = 0;

	int errors = 0;

	char protocol_file[1024], *protocol;

	fp = fopen( filename, "r" );
	if ( !fp ) {
		// Signal the error.
		fMessageBox( MB_OK, "RunSession", "    Error opening session file %s for read.\n", filename );
		// Tell the caller that we had just the one error.
		exit( -1 );
	}

	fOutputDebugString( "\n  File: %s", filename );

	protocols = 0;

	// Fill the menu line-by-line.
	while ( fgets( line, sizeof( line ), fp ) ) {

		line_n++;
		tokens = ParseCommaDelimitedLine( token, line );
		fOutputDebugString( "\n  Line:   %s", line );
		fOutputDebugString( "Tokens: %d\n", tokens );
		for ( i = 0; i < tokens; i++ ) fOutputDebugString( "%2d %s\n", i, token[i] );

		if ( tokens >= 4 ) {
			// This parameter is the name of the protocole file.
			strcpy( protocol_file, token[2] );
			// Check if it exists and is readable.
			if ( strcmp( protocol_file, "ignore" ) && _access( protocol_file, 0x00 ) ) {
				fMessageBox( MB_OK, "RunSession", "  %s Line %03d Cannot access protocol file: %s\n", filename, line_n, protocol_file );
			}	
			else {
				strcpy( ProtocolFilePath[protocols], token[2] );
				strcpy( ProtocolLabel[protocols], token[3] );
				protocols++;
			}
		}
	}

	fill_protocol_menu( ProtocolLabel, ProtocolFilePath, "Select protocol and press OK.", protocols );
	do {
		protocol = select_protocol_from_menu();
	} while ( !strcmp( protocol, "ignore" ));
	fOutputDebugString( "Selected protocol path: %s\n", protocol );
	if ( protocol && strcmp( protocol, "ignore" ) ) RunProtocol( apparatus, protocol );
	fclose( fp );
	return( errors );

}

/*********************************************************************************************************************************/

int RunSubject ( DexApparatus *apparatus, char *filename ) {

	FILE *fp;

	int tokens;
	char *token[MAX_TOKENS];
	char line[2048];
	int line_n = 0;
	int	i;

	char SubjectFilePath[MAX_MENU_ITEMS][1024];
	char SubjectLabel[MAX_MENU_ITEMS][64];
	int  subjects = 0;

	int errors = 0;

	char session_file[1024], *session;

	fp = fopen( filename, "r" );
	if ( !fp ) {
		// Signal the error.
		fMessageBox( MB_OK, "RunSubject", "    Error opening session file %s for read.\n", filename );
		// Tell the caller that we had just the one error.
		exit( -1 );
	}

	fOutputDebugString( "File: %s/n", filename );

	subjects = 0;

	// Fill the menu line-by-line.
	while ( fgets( line, sizeof( line ), fp ) ) {

		line_n++;
		tokens = ParseCommaDelimitedLine( token, line );
		fOutputDebugString( "\n  Line:   %s", line );
		fOutputDebugString( "Tokens: %d\n", tokens );
		for ( i = 0; i < tokens; i++ ) fOutputDebugString( "%2d %s\n", i, token[i] );

		if ( tokens >= 5 ) {
			// This parameter is the name of the session file.
			strcpy( session_file, token[3] );
			// Check if it exists and is readable.
			if ( _access( session_file, 0x00 ) ) {
				fMessageBox( MB_OK, "RunSubject", "  %s Line %03d Cannot access session file: %s\n", filename, line_n, session_file );
			}	
			else {
				strcpy( SubjectFilePath[subjects], token[3] );
				strcpy( SubjectLabel[subjects], token[4] );
				subjects++;
			}
		}
	}

	fill_protocol_menu( SubjectLabel, SubjectFilePath, "Select subject ID and press OK.", subjects );
	session = select_protocol_from_menu();
	fOutputDebugString( "Selected session path: %s\n", session );
	if ( session ) RunSession( apparatus, session );
	fclose( fp );
	return( errors );

}
